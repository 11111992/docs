[
{
	"uri": "/using-pack/building-app/",
	"title": "Building app images with `build`",
	"tags": [],
	"description": "",
	"content": " Building app images using build pack build enables app developers to create runnable app images from source code using buildpacks.\n$ pack build \u0026lt;image-name\u0026gt; Example: Building using the default builder image In the following example, an app image is created from Node.js application source code.\n$ cd /path/to/node/app $ pack build my-app:my-tag # ... Detect, analyze and build output  Successfully built 2452b4b1fce1 Successfully tagged my-app:my-tag In this case, the default builder is used, and an appropriate buildpack is automatically selected from the builder based on the app source code. To understand more about what builders are and how to create or use them, see the Working with builders using create-builder section.\nTo publish the produced image to an image registry, include the --publish flag:\n$ pack build private-registry.example.com/my-app:my-tag --publish Example: Building using a specified buildpack In the following example, an app image is created from Node.js application source code, using a buildpack chosen by the user.\n$ cd /path/to/node/app $ pack build my-app:my-tag --buildpack path/to/some/buildpack # ... *** DETECTING WITH MANUALLY-PROVIDED GROUP: 2018/10/29 18:31:05 Group: Name Of Some Buildpack: pass # ...  Successfully built 2452b4b1fce1 Successfully tagged my-app:my-tag The message DETECTING WITH MANUALLY-PROVIDED GROUP indicates that the buildpack was chosen by the user, rather than by the automated detection process.\nThe --buildpack parameter can be - a path to a directory - a path to a .tgz file - a URL to a .tgz file, or - the ID of a buildpack located in a builder\nBuilding explained To create an app image, build executes one or more buildpacks against the app\u0026rsquo;s source code. Each buildpack inspects the source code and provides relevant dependencies. An image is then generated from the app\u0026rsquo;s source code and these dependencies.\nBuildpacks are compatible with one or more stacks. A stack designates a build image and a run image. During the build process, a stack\u0026rsquo;s build image becomes the environment in which buildpacks are executed, and its run image becomes the base for the final app image. For more information on working with stacks, see the Managing stacks section.\nBuildpacks can be bundled together with a specific stack\u0026rsquo;s build image, resulting in a builder image (note the \u0026ldquo;er\u0026rdquo; ending). Builders provide the most convenient way to distribute buildpacks for a given stack. For more information on working with builders, see the Working with builders using create-builder section.\n"
},
{
	"uri": "/",
	"title": "Creating a Cloud Native Buildpack",
	"tags": [],
	"description": "",
	"content": " This is a step by step tutorial for creating a Ruby Cloud Native Buildpack. This tutorial will cover the following concepts:\n Buildpack Detection Buildpack Image Layering Buildpack Caching Making an OCI image Runnable  All source code from this tutorial is available here.\nPrequesites Before we get started make sure you have the following installed on your system\n Docker Community Edition pack\n  Setup Your Local Environment First we will want to clone a sample ruby app that you can use when developing the ruby cloud native buildpack\nmkdir workspace cd workspace git clone \u0026lt;path to sample ruby app\u0026gt;  Next we want to create the directory where you will create your buildpack\ncd workspace mkdir ruby-cnb  Finally, make sure your local docker daemon is running by running the following command\ndocker version  The following output should appear\nClient: Version: 18.06.1-ce API version: 1.38 Go version: go1.10.3 Git commit: e68fc7a Built: Tue Aug 21 17:21:31 2018 OS/Arch: darwin/amd64 Experimental: false Server: Engine: Version: 18.06.1-ce API version: 1.38 (minimum version 1.12) Go version: go1.10.3 Git commit: e68fc7a Built: Tue Aug 21 17:29:02 2018 OS/Arch: linux/amd64 Experimental: true  Create the Building Blocks of a Cloud Native Buildpack Now we will setup the buildpack scaffolding. You will need to make these files in your ruby-cnb directory\ncd ruby-cnb  buildpack.toml Once you are in the directory. You will need to create a buildpack.toml file in that directory. This file must exist in the root directory of your buildpack so the pack cli knows it is a buildpack and it can apply the build lifecycle to it.\nCreate the buildpack.toml file and copy the following into it\n#Buidpack ID and metadata [buildpack] id = \u0026quot;com.examples.buildpacks.ruby\u0026quot; version = \u0026quot;0.0.1\u0026quot; name = \u0026quot;Ruby Buildpack\u0026quot; #Stack the buildpack will work with [[stacks]] id = [\u0026quot;io.buildpacks.stacks.bionic\u0026quot;]  You will notice two specific fields in the file: buildpack ID and stack ID. The buildpack ID is the way you will reference the buildpack when you create buildpack groups, builders, etc. The stack ID is the root file system in which the buildpack will be built. This example is bulit on ubuntu bionic.\nDetect and Build Next you will need to create the detect and build scripts. These files must exist in a bin directory in your buildpack directory.\nCreate your bin directory and the change to that directory.\nmkdir bin cd bin  Now create your detect file in the bin directory and copy in the following content\n#!/usr/bin/env bash set -eo pipefail exit 1  Now create your build file in the bin directory and copy in the following content\n#!/usr/bin/env bash set -eo pipefail echo \u0026quot;---\u0026gt; Ruby Buildpack\u0026quot; exit 1  You will need to make both of these files executable, so run the following command.\nchmod +x detect build  These two files are now executable detect and build scripts. Now you can run your use your buildpack.\nUsing your buildpack with pack In order to test your buildpack, you will need to run the buildpack against your sample ruby app using the pack cli.\nRun the following pack command\npack build test-ruby-app --buildpack workspace/ruby-cnb --path workspace/ruby-sample-app/  The pack build command takes in your buildpack directory as the --buildpack argument and the ruby sample app as the --path argument\nAfter successfully running the command you should see the following output. You should see that it failed to detect because the detect script was setup to fail\n2018/10/16 09:59:00 Selected run image 'packs/run' from stack 'io.buildpacks.stacks.bionic' *** DETECTING: 2018/10/16 14:59:04 Group: Ruby Buildpack: error (1) 2018/10/16 14:59:04 Error: failed to detect Error: run detect container: failed with status code: 6  Detecting Your Ruby App Next you will want to actually detect that the app your are building is a ruby app. In order to do this you will need to check for a Gemfile.\nReplace exit 1 with the following check in your detect script\nif [[ ! -f Gemfile ]]; then exit 100 fi  And now your detect script will look like this\n#!/usr/bin/env bash set -eo pipefail if [[ ! -f Gemfile ]]; then exit 100 fi  Next, rebuild your app with your updated buildpack\npack build test-ruby-app --buildpack workspace/ruby-cnb --path workspace/ruby-sample-app/  You will see the following output\n2018/10/16 10:16:36 Selected run image 'packs/run' from stack 'io.buildpacks.stacks.bionic' *** DETECTING: 2018/10/16 15:16:40 Group: Ruby Buildpack: pass *** ANALYZING: Reading information from previous image for possible re-use 2018/10/16 10:16:41 WARNING: skipping analyze, image not found *** BUILDING: ---\u0026gt; Ruby Buildpack 2018/10/16 15:16:42 Error: failed to : exit status 1 Error: failed with status code: 7  Notice that detect now passes because there is a valid Gemfile in the ruby app at ~/ruby-sample-app, but now build fails because it is coded to do so.\nYou will also notice ANALYZE now appears in the build output. This step is part of the buildpack lifecycle that looks to see if any previous image builds have layers that the buildpack can re-use. We will get into this topic in more detail later.\nBuilding Your Ruby App Next we will make the build step work. This will a few updates to the build script.\nWe need to read the launch directory passed in by build lifecycle - learn more about the lifecycle here\nlaunchdir=$3  We need to create a ruby layer in the image\nmkdir -p $launchdir/ruby touch $launchdir/ruby.toml  We will need to download ruby\nruby_url=https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/heroku-18/ruby-2.5.1.tgz wget -q -O - \u0026quot;$ruby_url\u0026quot; | tar -xzf - -C \u0026quot;$launchdir/ruby\u0026quot;  We will need to download bundler\nbundler_url=https://buildpacks.cloudfoundry.org/dependencies/bundler/bundler-1.16.6-any-stack-77354698.tgz mkdir -p $launchdir/bundler wget -q -O - \u0026quot;$bundler_url\u0026quot; | tar -xzf - -C \u0026quot;$launchdir/bundler\u0026quot;  Finally, we will need to install bundle and then run bundle install\ngem install bundler bundle install  Your build script will now look like this\n#!/usr/bin/env bash set -eo pipefail # Set the launchdir variable to be the third argument from the build lifecycle launchdir=$3 echo \u0026quot;---\u0026gt; Ruby Buildpack\u0026quot; echo \u0026quot;---\u0026gt; Downloading and extracting ruby\u0026quot; mkdir -p $launchdir/ruby touch $launchdir/ruby.toml ruby_url=https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/heroku-18/ruby-2.5.1.tgz wget -q -O - \u0026quot;$ruby_url\u0026quot; | tar -xzf - -C \u0026quot;$launchdir/ruby\u0026quot; # Make ruby and bundler accessible in this script export PATH=$PATH:$launchdir/ruby/bin export LD_LIBRARY_PATH=${LD_LIBRARY_PATH:+${LD_LIBRARY_PATH}:}$launchdir/ruby/lib echo \u0026quot;---\u0026gt; Installing bundler\u0026quot; gem install bundler echo \u0026quot;---\u0026gt; Installing gems\u0026quot; bundle install  Now if you build your app again\npack build test-ruby-app --buildpack workspace/ruby-cnb --path workspace/ruby-sample-app/  You will see the following output\n2018/10/16 14:20:47 Selected run image 'packs/run' from stack 'io.buildpacks.stacks.bionic' *** DETECTING: 2018/10/16 19:20:49 Group: Ruby Buildpack: pass *** ANALYZING: Reading information from previous image for possible re-use 2018/10/16 14:20:50 WARNING: skipping analyze, image not found *** BUILDING: ---\u0026gt; Ruby Buildpack ---\u0026gt; Downloading and extracting ruby ---\u0026gt; Installing bundler Successfully installed bundler-1.16.6 Parsing documentation for bundler-1.16.6 Installing ri documentation for bundler-1.16.6 Done installing documentation for bundler after 3 seconds 1 gem installed ---\u0026gt; Installing gems Fetching gem metadata from https://rubygems.org/.............. Using bundler 1.16.6 Fetching rack 2.0.5 Installing rack 2.0.5 Fetching roda 3.13.0 Installing roda 3.13.0 Bundle complete! 1 Gemfile dependency, 3 gems now installed. Use `bundle info [gemname]` to see where a bundled gem is installed.  After building the ruby app, the buildpack now creates a docker file based on the output of build and then runs it\n*** EXPORTING: Step 1/4 : FROM packs/run *** This is the run image from your stack *** ---\u0026gt; aebbb14d9529 Step 2/4 : ADD --chown=pack:pack /workspace/app /workspace/app *** This is the app *** ---\u0026gt; f248b539eb0b Step 3/4 : ADD --chown=pack:pack /workspace/config /workspace/config ** Metadata for runtime ** ---\u0026gt; 74fb93aaa030 Step 4/4 : ADD --chown=pack:pack /workspace/io.buildpacks.samples.ruby/ruby /workspace/io.buildpacks.samples.ruby/ruby *** This is the ruby interpreter that the buildpack placed as a layer *** ---\u0026gt; 3d096514cf24 ---\u0026gt; 3d096514cf24 Successfully built 3d096514cf24 Successfully tagged test-ruby-app:latest Step 1/2 : FROM test-ruby-app *** Set metadata labels of the image *** ---\u0026gt; 3d096514cf24 Step 2/2 : LABEL io.buildpacks.lifecycle.metadata='{\u0026quot;app\u0026quot;:{\u0026quot;name\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;sha\u0026quot;:\u0026quot;sha256:1e13e329d407844821c3aa5bd22d74feb5cae32af5aa85c82b5271a20e51615d\u0026quot;},\u0026quot;config\u0026quot;:{\u0026quot;sha\u0026quot;:\u0026quot;sha256:45f0d1cb7eee98d807a7932b4fcf8a5c0c5b2c1aad0a223994922d68885457ad\u0026quot;},\u0026quot;buildpacks\u0026quot;:[{\u0026quot;key\u0026quot;:\u0026quot;io.buildpacks.samples.ruby\u0026quot;,\u0026quot;name\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;layers\u0026quot;:{\u0026quot;ruby\u0026quot;:{\u0026quot;sha\u0026quot;:\u0026quot;sha256:f5fa2b809b8847000234da59c2f346e066736efbcd5a84ffddf02993b0fd23e9\u0026quot;,\u0026quot;data\u0026quot;:{}}}}],\u0026quot;runimage\u0026quot;:{\u0026quot;name\u0026quot;:\u0026quot;packs/run\u0026quot;,\u0026quot;sha\u0026quot;:\u0026quot;sha256:2ace261ebe9f5936ea72b6290019cda476db6a0b3a4d5d64039c61b45e46091f\u0026quot;}}' ---\u0026gt; Running in 49bca3c53f9f ---\u0026gt; af8d138f6c96 ---\u0026gt; af8d138f6c96 Successfully built af8d138f6c96 Successfully tagged test-ruby-app:latest  Making the Application Runnable Next we want to set a default start command for the application in the image. You will want to add the following code to then end of your build script.\n# Set default start command echo 'processes = [{ type = \u0026quot;web\u0026quot;, command = \u0026quot;rackup -p 8080 --host 0.0.0.0\u0026quot;}]' \u0026gt; \u0026quot;$launchdir/launch.toml\u0026quot;  This sets your default start command.\nYour full build script should now look like this\n#!/usr/bin/env bash set -eo pipefail # Set the launchdir variable to be the third argument from the build lifecycle launchdir=$3 echo \u0026quot;---\u0026gt; Ruby Buildpack\u0026quot; echo \u0026quot;---\u0026gt; Downloading and extracting ruby\u0026quot; mkdir -p $launchdir/ruby touch $launchdir/ruby.toml ruby_url=https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/heroku-18/ruby-2.5.1.tgz wget -q -O - \u0026quot;$ruby_url\u0026quot; | tar -xzf - -C \u0026quot;$launchdir/ruby\u0026quot; # Make ruby and bundler accessible in this script export PATH=$PATH:$launchdir/ruby/bin export LD_LIBRARY_PATH=${LD_LIBRARY_PATH:+${LD_LIBRARY_PATH}:}$launchdir/ruby/lib echo \u0026quot;---\u0026gt; Installing bundler\u0026quot; gem install bundler echo \u0026quot;---\u0026gt; Installing gems\u0026quot; bundle install # Set default start command echo 'processes = [{ type = \u0026quot;web\u0026quot;, command = \u0026quot;rackup -p 8080 --host 0.0.0.0\u0026quot;}]' \u0026gt; \u0026quot;$launchdir/launch.toml\u0026quot;  Now you will rebuild your app using the updated buildpack with the launch command\npack build test-ruby-app --buildpack workspace/ruby-cnb --path workspace/ruby-sample-app/  And when you run docker run -p 8080:8080 test-ruby-app you should see you the WEBRICK webserver startup\n[2018-10-17 15:05:38] INFO WEBrick 1.4.2 [2018-10-17 15:05:38] INFO ruby 2.5.1 (2018-03-29) [x86_64-linux] [2018-10-17 15:05:38] INFO WEBrick::HTTPServer#start: pid=1 port=8080  You should also be able to access the app via your web browser at localhost:8080.\nImproving Buildpack Performance Through Caching Next we want to separate the ruby interpreter and bundled gems into different layers. This will allows us to cache the ruby layer and gem dependency layer separately, which helps speed up builds.\nCreating the Bundler Layer To do this replace the line\necho \u0026quot;---\u0026gt; Installing gems\u0026quot; bundle install  With the following\necho \u0026quot;---\u0026gt; Installing gems\u0026quot; mkdir \u0026quot;$launchdir/bundler\u0026quot; touch \u0026quot;$launchdir/bundler.toml\u0026quot; bundle install --path \u0026quot;$launchdir/bundler\u0026quot; --binstubs \u0026quot;$launchdir/bundler/bin\u0026quot;  Your full build script should now look like this\n#!/usr/bin/env bash set -eo pipefail # Set the launchdir variable to be the third argument from the build lifecycle launchdir=$3 echo \u0026quot;---\u0026gt; Ruby Buildpack\u0026quot; echo \u0026quot;---\u0026gt; Downloading and extracting ruby\u0026quot; mkdir -p $launchdir/ruby touch $launchdir/ruby.toml ruby_url=https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/heroku-18/ruby-2.5.1.tgz wget -q -O - \u0026quot;$ruby_url\u0026quot; | tar -xzf - -C \u0026quot;$launchdir/ruby\u0026quot; # Make ruby and bundler accessible in this script export PATH=$PATH:$launchdir/ruby/bin export LD_LIBRARY_PATH=${LD_LIBRARY_PATH:+${LD_LIBRARY_PATH}:}$launchdir/ruby/lib echo \u0026quot;---\u0026gt; Installing bundler\u0026quot; gem install bundler echo \u0026quot;---\u0026gt; Installing gems\u0026quot; mkdir \u0026quot;$launchdir/bundler\u0026quot; touch \u0026quot;$launchdir/bundler.toml\u0026quot; bundle install --path \u0026quot;$launchdir/bundler\u0026quot; --binstubs \u0026quot;$launchdir/bundler/bin\u0026quot; # Set default start command echo 'processes = [{ type = \u0026quot;web\u0026quot;, command = \u0026quot;rackup -p 8080 --host 0.0.0.0\u0026quot;}]' \u0026gt; \u0026quot;$launchdir/launch.toml\u0026quot;  Now when we run\npack build test-ruby-app --buildpack workspace/ruby-cnb --path workspace/ruby-sample-app/  You will see the following change during EXPORT\n*** EXPORTING: Step 1/5 : FROM packs/run ---\u0026gt; aebbb14d9529 Step 2/5 : ADD --chown=pack:pack /workspace/app /workspace/app ---\u0026gt; 218f662e7424 Step 3/5 : ADD --chown=pack:pack /workspace/config /workspace/config ---\u0026gt; 822b4af62763 Step 4/5 : ADD --chown=pack:pack /workspace/io.buildpacks.samples.ruby/bundler /workspace/io.buildpacks.samples.ruby/bundler *** Added bundler layer *** ---\u0026gt; 6312ef1f72db Step 5/5 : ADD --chown=pack:pack /workspace/io.buildpacks.samples.ruby/ruby /workspace/io.buildpacks.samples.ruby/ruby *** Added ruby layer *** ---\u0026gt; f30822d0d3e0 ---\u0026gt; f30822d0d3e0 Successfully built f30822d0d3e0 Successfully tagged test-ruby-app:latest Step 1/2 : FROM test-ruby-app ---\u0026gt; f30822d0d3e0 Step 2/2 : LABEL io.buildpacks.lifecycle.metadata='{\u0026quot;app\u0026quot;:{\u0026quot;name\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;sha\u0026quot;:\u0026quot;sha256:b6cf193d1e24768b5e6fedba9165156fc47ac68249549a079ab9611e546ed641\u0026quot;},\u0026quot;config\u0026quot;:{\u0026quot;sha\u0026quot;:\u0026quot;sha256:8a5961cc7bfdf64565631a31a6b70111bf65ac981f52ede8c6a5dca118f7fdc3\u0026quot;},\u0026quot;buildpacks\u0026quot;:[{\u0026quot;key\u0026quot;:\u0026quot;io.buildpacks.samples.ruby\u0026quot;,\u0026quot;name\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;layers\u0026quot;:{\u0026quot;bundler\u0026quot;:{\u0026quot;sha\u0026quot;:\u0026quot;sha256:24b55bd13e0f34511639ccc3d9f8931f0a4a6d0206f51bce2af74822a9481975\u0026quot;,\u0026quot;data\u0026quot;:{}},\u0026quot;ruby\u0026quot;:{\u0026quot;sha\u0026quot;:\u0026quot;sha256:56a9193f461c09ee566c5cece64cb3e1f0c87f8d95f1c0029ab8fbcf5208c71b\u0026quot;,\u0026quot;data\u0026quot;:{}}}}],\u0026quot;runimage\u0026quot;:{\u0026quot;name\u0026quot;:\u0026quot;packs/run\u0026quot;,\u0026quot;sha\u0026quot;:\u0026quot;sha256:2ace261ebe9f5936ea72b6290019cda476db6a0b3a4d5d64039c61b45e46091f\u0026quot;}}' ---\u0026gt; Running in b3b7cc1eafa0 ---\u0026gt; d66d877f6442 ---\u0026gt; d66d877f6442 Successfully built d66d877f6442 Successfully tagged test-ruby-app:latest  Caching Gem Dependencies Next we will start caching gem dependencies to help speed up the build if no new dependencies are needed.\nReplace the bundle logic from the previous step\necho \u0026quot;---\u0026gt; Installing gems\u0026quot; mkdir \u0026quot;$launchdir/bundler\u0026quot; touch \u0026quot;$launchdir/bundler.toml\u0026quot; bundle install --path \u0026quot;$launchdir/bundler\u0026quot; --binstubs \u0026quot;$launchdir/bundler/bin\u0026quot;  With this new logic that checks to see if any gems have been changed. This simply creates a checksum for the previous Gemfile and compares it to the checksum of the current Gemfile. If they are the same, the gems are reused. If they are not, the new gems are installed.\n### START BUNDLER LAYER #Compares previous Gemfile.lock checksum to the current Gemfile.lock local_bundler_checksum=$(sha256sum Gemfile.lock | cut -d ' ' -f 1) remote_bundler_checksum=$(cat \u0026quot;$launchdir/bundler.toml\u0026quot; | yj -t | jq -r .lock_checksum 2\u0026gt;/dev/null || echo 'not found') if [[ -f Gemfile.lock \u0026amp;\u0026amp; $local_bundler_checksum == $remote_bundler_checksum \u0026amp;\u0026amp; $reused_ruby == 'true' ]] ; then #Determine no gem depencencies have changed, so can reuse existing gems without running bundle install echo \u0026quot;---\u0026gt; Reusing gems\u0026quot; bundle config --local path \u0026quot;$launchdir/bundler\u0026quot; \u0026gt;/dev/null bundle config --local bin \u0026quot;$launchdir/bundler/bin\u0026quot; \u0026gt;/dev/null else #Determine there has been a gem dependency change and will create a new version of the bundler layer to install new gems echo \u0026quot;---\u0026gt; Installing gems\u0026quot; mkdir \u0026quot;$launchdir/bundler\u0026quot; echo \u0026quot;lock_checksum = \\\u0026quot;$local_bundler_checksum\\\u0026quot;\u0026quot; \u0026gt; \u0026quot;$launchdir/bundler.toml\u0026quot; bundle install --path \u0026quot;$launchdir/bundler\u0026quot; --binstubs \u0026quot;$launchdir/bundler/bin\u0026quot; fi ### END BUNDLER LAYER  Your full build script will now look like this\n#!/usr/bin/env bash set -eo pipefail # Set the launchdir variable to be the third argument from the build lifecycle launchdir=$3 echo \u0026quot;---\u0026gt; Ruby Buildpack\u0026quot; echo \u0026quot;---\u0026gt; Downloading and extracting ruby\u0026quot; mkdir -p $launchdir/ruby touch $launchdir/ruby.toml ruby_url=https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/heroku-18/ruby-2.5.1.tgz wget -q -O - \u0026quot;$ruby_url\u0026quot; | tar -xzf - -C \u0026quot;$launchdir/ruby\u0026quot; # Make ruby and bundler accessible in this script export PATH=$PATH:$launchdir/ruby/bin export LD_LIBRARY_PATH=${LD_LIBRARY_PATH:+${LD_LIBRARY_PATH}:}$launchdir/ruby/lib echo \u0026quot;---\u0026gt; Installing bundler\u0026quot; gem install bundler ### START BUNDLER LAYER #Compares previous Gemfile.lock checksum to the current Gemfile.lock local_bundler_checksum=$(sha256sum Gemfile.lock | cut -d ' ' -f 1) remote_bundler_checksum=$(cat \u0026quot;$launchdir/bundler.toml\u0026quot; | yj -t | jq -r .lock_checksum 2\u0026gt;/dev/null || echo 'not found') if [[ -f Gemfile.lock \u0026amp;\u0026amp; $local_bundler_checksum == $remote_bundler_checksum \u0026amp;\u0026amp; $reused_ruby == 'true' ]] ; then #Determine no gem depencencies have changed, so can reuse existing gems without running bundle install echo \u0026quot;---\u0026gt; Reusing gems\u0026quot; bundle config --local path \u0026quot;$launchdir/bundler\u0026quot; \u0026gt;/dev/null bundle config --local bin \u0026quot;$launchdir/bundler/bin\u0026quot; \u0026gt;/dev/null else #Determine there has been a gem dependency change and will create a new version of the bundler layer to install new gems echo \u0026quot;---\u0026gt; Installing gems\u0026quot; mkdir \u0026quot;$launchdir/bundler\u0026quot; echo \u0026quot;lock_checksum = \\\u0026quot;$local_bundler_checksum\\\u0026quot;\u0026quot; \u0026gt; \u0026quot;$launchdir/bundler.toml\u0026quot; bundle install --path \u0026quot;$launchdir/bundler\u0026quot; --binstubs \u0026quot;$launchdir/bundler/bin\u0026quot; fi ### END BUNDLER LAYER # Set default start command echo 'processes = [{ type = \u0026quot;web\u0026quot;, command = \u0026quot;rackup -p 8080 -o 0.0.0.0\u0026quot;}]' \u0026gt; \u0026quot;$launchdir/launch.toml\u0026quot;  Now when you build your app it will now generate the Gemfile checksum for the first time and store it in the image\npack build test-ruby-app --buildpack workspace/ruby-cnb --path workspace/ruby-sample-app/  And if you build the app again\npack build test-ruby-app --buildpack workspace/ruby-cnb --path workspace/ruby-sample-app/  You will see the new caching logic work\n*** BUILDING: ---\u0026gt; Ruby Buildpack ---\u0026gt; Downloading and extracting ruby ---\u0026gt; Installing bundler Successfully installed bundler-1.16.6 Parsing documentation for bundler-1.16.6 Installing ri documentation for bundler-1.16.6 Done installing documentation for bundler after 2 seconds 1 gem installed ---\u0026gt; Reusing gems *** Gems were successfully cached ***  Cache Ruby Now we will add the logic to cache the ruby interpreter to speed up build times if a new version of ruby is not needed.\nFirst we need to capture the cache directory from the build lifecycle.\ncachedir=$2  Next we will set a desired ruby version that we will support as a variable, in this instance ruby 2.5.1.\nruby_version=2.5.1  Next we will update our ruby paths inside the script to point to the $cachedir instead of the $launchdir.\nexport PATH=$PATH:$cachedir/ruby/bin export LD_LIBRARY_PATH=${LD_LIBRARY_PATH:+${LD_LIBRARY_PATH}:}$cachedir/ruby/lib  Next we will add the ruby caching logic that checks to see if ruby has been successfully cached with the correct version.\nThis logic checks to see if the cached version captured in ruby.toml matches the desired version defined in the ruby_version variable. If it is the same - it reuses the cached version, if it is not (or does not exist) it will download and cache the correct version.\nif [[ $ruby_version == $([[ -f $cachedir/ruby.toml ]] \u0026amp;\u0026amp; cat \u0026quot;$cachedir/ruby.toml\u0026quot; | yj -t | jq -r .version) ]] ; then echo \u0026quot;---\u0026gt; Reusing ruby $ruby_version\u0026quot; else echo \u0026quot;---\u0026gt; Downloading and extracting ruby\u0026quot; rm -rf $cachedir/ruby mkdir -p $cachedir/ruby echo \u0026quot;version = \\\u0026quot;$ruby_version\\\u0026quot;\u0026quot; \u0026gt; \u0026quot;$cachedir/ruby.toml\u0026quot; ruby_url=https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/heroku-18/ruby-$ruby_version.tgz wget -q -O - \u0026quot;$ruby_url\u0026quot; | tar -xzf - -C \u0026quot;$cachedir/ruby\u0026quot; echo \u0026quot;---\u0026gt; Installing bundler\u0026quot; gem install bundler fi  Next we check to see if the desired version of ruby matches the previous images version of ruby in the $launchdir. If it is the same, it is reused, if it is not it is copied to the $launchdir from the $cachedir\nif [[ $ruby_version == $([[ -f $launchdir/ruby.toml ]] \u0026amp;\u0026amp; cat \u0026quot;$launchdir/ruby.toml\u0026quot; | yj -t | jq -r .version) ]] ; then echo \u0026quot;---\u0026gt; Reusing ruby layer\u0026quot; else echo \u0026quot;---\u0026gt; Adding ruby layer\u0026quot; cp $cachedir/ruby.toml $launchdir/ruby.toml cp -r $cachedir/ruby $launchdir/ruby fi  Now your full build script will look like this\n#!/usr/bin/env bash set -eo pipefail # Set the launchdir variable to be the third argument from the build lifecycle cachedir=$2 launchdir=$3 echo \u0026quot;---\u0026gt; Ruby Buildpack\u0026quot; ruby_version=2.5.1 # Make ruby and bundler accessible in this script export PATH=$PATH:$cachedir/ruby/bin export LD_LIBRARY_PATH=${LD_LIBRARY_PATH:+${LD_LIBRARY_PATH}:}$cachedir/ruby/lib if [[ $ruby_version == $([[ -f $cachedir/ruby.toml ]] \u0026amp;\u0026amp; cat \u0026quot;$cachedir/ruby.toml\u0026quot; | yj -t | jq -r .version) ]] ; then echo \u0026quot;---\u0026gt; Reusing ruby $ruby_version\u0026quot; else echo \u0026quot;---\u0026gt; Downloading and extracting ruby - $ruby_version\u0026quot; rm -rf $cachedir/ruby mkdir -p $cachedir/ruby echo \u0026quot;version = \\\u0026quot;$ruby_version\\\u0026quot;\u0026quot; \u0026gt; \u0026quot;$cachedir/ruby.toml\u0026quot; ruby_url=https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/heroku-18/ruby-$ruby_version.tgz wget -q -O - \u0026quot;$ruby_url\u0026quot; | tar -xzf - -C \u0026quot;$cachedir/ruby\u0026quot; echo \u0026quot;---\u0026gt; Installing bundler\u0026quot; gem install bundler fi if [[ $ruby_version == $([[ -f $launchdir/ruby.toml ]] \u0026amp;\u0026amp; cat \u0026quot;$launchdir/ruby.toml\u0026quot; | yj -t | jq -r .version) ]] ; then echo \u0026quot;---\u0026gt; Reusing ruby layer\u0026quot; else echo \u0026quot;---\u0026gt; Adding ruby layer\u0026quot; cp $cachedir/ruby.toml $launchdir/ruby.toml cp -r $cachedir/ruby $launchdir/ruby fi ### START BUNDLER LAYER #Compares previous Gemfile.lock checksum to the current Gemfile.lock local_bundler_checksum=$(sha256sum Gemfile.lock | cut -d ' ' -f 1) remote_bundler_checksum=$(cat \u0026quot;$launchdir/bundler.toml\u0026quot; | yj -t | jq -r .lock_checksum 2\u0026gt;/dev/null || echo 'not found') if [[ -f Gemfile.lock \u0026amp;\u0026amp; $local_bundler_checksum == $remote_bundler_checksum \u0026amp;\u0026amp; $reused_ruby == 'true' ]] ; then #Determine no gem depencencies have changed, so can reuse existing gems without running bundle install echo \u0026quot;---\u0026gt; Reusing gems\u0026quot; bundle config --local path \u0026quot;$launchdir/bundler\u0026quot; \u0026gt;/dev/null bundle config --local bin \u0026quot;$launchdir/bundler/bin\u0026quot; \u0026gt;/dev/null else #Determine there has been a gem dependency change and will create a new version of the bundler layer to install new gems echo \u0026quot;---\u0026gt; Installing gems\u0026quot; mkdir \u0026quot;$launchdir/bundler\u0026quot; echo \u0026quot;lock_checksum = \\\u0026quot;$local_bundler_checksum\\\u0026quot;\u0026quot; \u0026gt; \u0026quot;$launchdir/bundler.toml\u0026quot; bundle install --path \u0026quot;$launchdir/bundler\u0026quot; --binstubs \u0026quot;$launchdir/bundler/bin\u0026quot; fi ### END BUNDLER LAYER # Set default start command echo 'processes = [{ type = \u0026quot;web\u0026quot;, command = \u0026quot;rackup -p 8080\u0026quot;}]' \u0026gt; \u0026quot;$launchdir/launch.toml\u0026quot;  Now when you run\npack build test-ruby-app --buildpack workspace/ruby-cnb --path workspace/ruby-sample-app/  You will notice that the ruby layer is being added to the cache and then added to the launch directory.\n*** BUILDING: ---\u0026gt; Ruby Buildpack ---\u0026gt; Downloading and extracting ruby *** Downloads Ruby *** ---\u0026gt; Installing bundler Successfully installed bundler-1.16.6 Parsing documentation for bundler-1.16.6 Installing ri documentation for bundler-1.16.6 Done installing documentation for bundler after 2 seconds 1 gem installed ---\u0026gt; Adding ruby layer *** Adding ruby to launch directory from cache *** ---\u0026gt; Reusing gems  If you rebuild your app with the cached version of ruby using\npack build test-ruby-app --buildpack workspace/ruby-cnb --path workspace/ruby-sample-app/  You will now see the build is using the cached version of ruby.\n*** BUILDING: ---\u0026gt; Ruby Buildpack ---\u0026gt; Reusing ruby 2.5.1 *** Reusing cached ruby *** ---\u0026gt; Reusing ruby layer *** Reusing the ruby launch layer *** ---\u0026gt; Reusing gems  Select Ruby Version Next we will update the detect script to check for a specific version of ruby that the user has defined in their application via a .ruby-version file,\nAppend the following version check to the end of your detect script\nversion=2.5.1 if [[ -f .ruby-version ]]; then version=$(cat .ruby-version | tr -d '[:space:]') fi echo \u0026quot;ruby = { version = \\\u0026quot;$version\\\u0026quot; }\u0026quot;  Your full script will now look like this\n#!/usr/bin/env bash set -eo pipefail if [[ ! -f Gemfile ]]; then exit 100 fi version=2.5.1 if [[ -f .ruby-version ]]; then version=$(cat .ruby-version | tr -d '[:space:]') fi echo \u0026quot;ruby = { version = \\\u0026quot;$version\\\u0026quot; }\u0026quot;  Then you will need to update your build script to look for this version from the detect script\nReplace\nruby_version=2.5.1  With this\nruby_version=$(yj -t | jq -r .ruby.version)  Now in your ruby app, create a file named .ruby-version and add the following line to it\n2.5.0  Now when run\npack build test-ruby-app --buildpack workspace/ruby-cnb --path workspace/ruby-sample-app/  You will see the new ruby version downloaded and installed\n*** BUILDING: ---\u0026gt; Ruby Buildpack ---\u0026gt; Downloading and extracting ruby - 2.5.0 ---\u0026gt; Installing bundler Successfully installed bundler-1.16.6 Parsing documentation for bundler-1.16.6 Installing ri documentation for bundler-1.16.6 Done installing documentation for bundler after 3 seconds 1 gem installed ---\u0026gt; Adding ruby layer ---\u0026gt; Reusing gems  That\u0026rsquo;s it! You\u0026rsquo;ve created your first Cloud Native Buildpack that uses detection, image layers and caching to create a runnable OCI image. In a seperate tutorial we will cover distributing this buildpack for developer use via a Cloud Native Buildpack builder.\n"
},
{
	"uri": "/using-pack/",
	"title": "Getting Started with pack",
	"tags": [],
	"description": "",
	"content": " pack makes it easy for  application developers to use buildpacks to convert code into runnable images buildpack authors to develop and package buildpacks for distribution  Contents  Building app images using build  Example: Building using the default builder image Example: Building using a specified buildpack Building explained  Updating app images using rebase  Example: Rebasing an app image Rebasing explained  Working with builders using create-builder  Example: Creating a builder from buildpacks Builders explained  Managing stacks  Example: Adding a stack Example: Updating a stack Example: Deleting a stack Example: Setting the default stack Listing stacks  Resources Development  Resources  Buildpack \u0026amp; Platform Specifications  Development To run the tests, simply run:\n$ go test"
},
{
	"uri": "/using-pack/update-app-rebase/",
	"title": "Updating app images using `rebase`",
	"tags": [],
	"description": "",
	"content": " Updating app images using rebase The pack rebase command allows app developers to rapidly update an app image when its stack\u0026rsquo;s run image has changed. By using image layer rebasing, this command avoids the need to fully rebuild the app.\n$ pack rebase \u0026lt;image-name\u0026gt; Example: Rebasing an app image Consider an app image my-app:my-tag that was originally built using the default builder. That builder\u0026rsquo;s stack has a run image called pack/run. Running the following will update the base of my-app:my-tag with the latest version of pack/run.\n$ pack rebase my-app:my-tag Like build, rebase has a --publish flag that can be used to publish the updated app image to a registry.\nRebasing explained At its core, image rebasing is a simple process. By inspecting an app image, rebase can determine whether or not a newer version of the app\u0026rsquo;s base image exists (either locally or in a registry). If so, rebase updates the app image\u0026rsquo;s layer metadata to reference the newer base image version.\n"
},
{
	"uri": "/using-pack/working-with-builders/",
	"title": "Working with builders",
	"tags": [],
	"description": "",
	"content": " Working with builders using create-builder pack create-builder enables buildpack authors and platform operators to bundle a collection of buildpacks into a single image for distribution and use with a specified stack.\n$ pack create-builder \u0026lt;image-name\u0026gt; --builder-config \u0026lt;path-to-builder-toml\u0026gt; Example: Creating a builder from buildpacks In this example, a builder image is created from buildpacks org.example.buildpack-1 and org.example.buildpack-2. A builder.toml file provides necessary configuration to the command.\n[[buildpacks]] id = \u0026#34;org.example.buildpack-1\u0026#34; uri = \u0026#34;relative/path/to/buildpack-1\u0026#34; # URIs without schemes are read as paths relative to builder.toml [[buildpacks]] id = \u0026#34;org.example.buildpack-2\u0026#34; uri = \u0026#34;https://example.org/buildpacks/buildpack-2.tgz\u0026#34; [[groups]] [[groups.buildpacks]] id = \u0026#34;org.example.buildpack-1\u0026#34; version = \u0026#34;0.0.1\u0026#34; [[groups.buildpacks]] id = \u0026#34;org.example.buildpack-2\u0026#34; version = \u0026#34;0.0.1\u0026#34; Running create-builder while supplying this configuration file will produce the builder image.\n$ pack create-builder my-builder:my-tag --builder-config path/to/builder.toml 2018/10/29 15:35:47 Pulling builder base image packs/build 2018/10/29 15:36:06 Successfully created builder image: my-builder:my-tag Like build, create-builder has a --publish flag that can be used to publish the generated builder image to a registry.\n The above example uses the default stack, whose build image is packs/build. The --stack parameter can be used to specify a different stack (currently, the only built-in stack is io.buildpacks.stacks.bionic). For more information about managing stacks and their associations with build and run images, see the Managing stacks section.\n The builder can then be used in build by running:\n$ pack build my-app:my-tag --builder my-builder:my-tag --buildpack org.example.buildpack-1 Builders explained A builder is an image containing a collection of buildpacks that will be executed, in the order that they appear in builder.toml, against app source code. A buildpack\u0026rsquo;s primary role is to inspect the source code, determine any dependencies that will be required to compile and/or run the app, and provide those dependencies as layers in the resulting image. This image\u0026rsquo;s base will be the build image associated with a given stack.\nIt\u0026rsquo;s important to note that the buildpacks in a builder are not actually executed until build is run.\n"
},
{
	"uri": "/using-pack/managing-stacks/",
	"title": "Managing Stacks",
	"tags": [],
	"description": "",
	"content": " Managing stacks As mentioned previously, a stack is associated with a build image and a run image. Stacks in pack\u0026rsquo;s configuration can be managed using the following commands:\n$ pack add-stack \u0026lt;stack-name\u0026gt; --build-image \u0026lt;build-image-name\u0026gt; --run-image \u0026lt;run-image-name1,run-image-name2,...\u0026gt;$ pack update-stack \u0026lt;stack-name\u0026gt; --build-image \u0026lt;build-image-name\u0026gt; --run-image \u0026lt;run-image-name1,run-image-name2,...\u0026gt;$ pack delete-stack \u0026lt;stack-name\u0026gt;$ pack set-default-stack \u0026lt;stack-name\u0026gt;  Technically, a stack can be associated with multiple run images, as a variant is needed for each registry to which an app image might be published when using --publish.\n Example: Adding a stack In this example, a new stack called org.example.my-stack is added and associated with build image my-stack/build and run image my-stack/run.\n$ pack add-stack org.example.my-stack --build-image my-stack/build --run-image my-stack/run Example: Updating a stack In this example, an existing stack called org.example.my-stack is updated with a new build image my-stack/build:v2 and a new run image my-stack/run:v2.\n$ pack add-stack org.example.my-stack --build-image my-stack/build:v2 --run-image my-stack/run:v2 Example: Deleting a stack In this example, the existing stack org.example.my-stack is deleted from pack\u0026rsquo;s configuration.\n$ pack delete-stack org.example.my-stack Example: Setting the default stack In this example, the default stack, used by create-builder, is set to org.example.my-stack.\n$ pack set-default-stack org.example.my-stack Listing stacks To inspect available stacks and their names (denoted by id), run:\n$ cat ~/.pack/config.toml ... [[stacks]] id = \u0026#34;io.buildpacks.stacks.bionic\u0026#34; build-images = [\u0026#34;packs/build\u0026#34;] run-images = [\u0026#34;packs/run\u0026#34;] [[stacks]] id = \u0026#34;org.example.my-stack\u0026#34; build-images = [\u0026#34;my-stack/build\u0026#34;] run-images = [\u0026#34;my-stack/run\u0026#34;] ...  Note that this method of inspecting available stacks will soon be replaced by a new command. The format of config.toml is subject to change at any time.\n "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/",
	"title": "Cloud Native Buildpack Documentation",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]